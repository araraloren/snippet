wit_bindgen::generate!({
    path: "wit",
    world: "c",
    with: {
        "snippet:plugin/types@0.1.0": generate,
        "snippet:plugin/language@0.1.0": generate,
        "snippet:plugin/compiler@0.1.0": generate,
    }
});

use std::path::PathBuf;

use exports::snippet::plugin::language::ErrorType;
use exports::snippet::plugin::language::Guest;
use snippet::plugin::compiler::Compiler;
use snippet::plugin::types::Lang;
use snippet::plugin::types::Mode;
use snippet::plugin::types::Optset;
use snippet::plugin::types::Services;
use snippet::plugin::types::Target;

pub struct Language;

impl Guest for Language {
    fn name() -> Lang {
        Lang::C
    }

    fn fmt() -> String {
        String::from("clang-format=--style=LLVM")
    }

    fn initialize_optset() -> Result<Optset, ErrorType> {
        Optset::default()
    }

    fn fill_optset(optset: Optset) -> Result<Optset, ErrorType> {
        optset.add_opt("-i=s: pass -i to compiler, include given header")?;
        optset.add_opt("-I=s: pass -I to compiler, add include header search path")?;
        optset.add_opt("-D=s: pass -D to compiler, add macro definition")?;
        optset.add_opt("-pp=s: add preprocess command to code")?;
        optset.add_opt("-w=b: pass -Wall -Wextra -Werror to compiler")?;
        Ok(optset)
    }

    // parser.add_opt("-help=b: display help message")?;
    // parser.add_opt("-S=b: running the compiler in assemble mode")?;
    // parser.add_opt("-E=b: running the compiler in expand mode")?;
    // parser.add_opt("-C=b: running the compiler in compile mode")?;
    // parser.add_opt("-e=s: append code to generator")?;
    // parser.add_opt("-r=b: ignore value of -e, read code from stdin")?;
    // parser.add_opt("-end=s: set input code terminator")?;
    // parser.add_opt("-o=s: set output name")?;
    // parser.add_opt("-p=b: display code before display stdout")?;
    // parser.add_opt("-l=s: pass -l to compiler, link given library")?;
    // parser.add_opt("-L=s: pass -L to compiler, add link library searh path")?;
    // parser.add_opt("-f=s: pass given flag -<f> to compiler")?;
    // parser.add_opt("-flag=s: pass given flag --<flag> to compiler")?;
    // parser.add_opt("-std=s: set language standard version")?;
    // parser.add_opt("-c=s: select given compiler")?;
    // parser.add_opt("-m=s: change the main function header")?;
    // parser.add_opt("-/c=b: don't clean target generated by compiler")?;
    // parser.add_opt("-args=s: pass arguments when execute binary")?;
    fn compile(optset: Optset, compiler: Compiler) -> Result<Target, ErrorType> {
        if let Ok(flags) = optset.get_vals_str("-f=s") {
            for flag in flags {
                compiler.add_arg(&format!("-{flag}"))?;
            }
        }
        if let Ok(flags) = optset.get_vals_str("-flag=s") {
            for flag in flags {
                compiler.add_arg(&format!("--{flag}"))?;
            }
        }
        if let Ok(include_paths) = optset.get_vals_str("-I=s") {
            for include_path in include_paths {
                compiler.add_include_path(&include_path)?;
            }
        }
        if let Ok(library_paths) = optset.get_vals_str("-L=s") {
            for library_path in library_paths {
                compiler.add_library_path(&library_path)?;
            }
        }

        if let Ok(definitions) = optset.get_vals_str("-D=s") {
            for definition in definitions {
                compiler.add_arg(&format!("-D{definition}"))?;
            }
        }
        if let Ok(wextra) = optset.get_val_bool("-w=b") {
            if wextra {
                compiler.add_arg("-Wall")?;
                compiler.add_arg("-Wextra")?;
                compiler.add_arg("-Werror")?;
            }
        }
        if let Ok(standard) = optset.get_val_str("-std=s") {
            compiler.set_standard(&standard)?;
        }
        let not_clean = optset.get_val_bool("-/c=b").unwrap_or_default();
        let assemble = optset.get_val_bool("-S=b").unwrap_or_default();
        let expand = optset.get_val_bool("-E=b").unwrap_or_default();
        let compile = optset.get_val_bool("-C=b").unwrap_or_default();

        #[allow(clippy::nonminimal_bool)]
        if (!assemble && expand && compile)
            || (assemble && !expand && compile)
            || (assemble && expand && !compile)
        {
            Services::log_debug("can't set `assemble`, `expand` or `compile` in same times")?;
            return Err(ErrorType::InvalidMode);
        }

        let read_from_stdin = optset.get_val_bool("-r=b").unwrap_or_default();
        let codes = optset.get_vals_str("-e=s").unwrap_or_default();
        let files = optset.get_vals_str("files").unwrap_or_default();
        let output = optset.get_val_str("-o=s").unwrap_or(
            if assemble {
                "a.s"
            } else if expand {
                "a.i"
            } else if compile {
                "a.o"
            } else {
                "a.out"
            }
            .to_string(),
        );

        Services::log_debug(&format!("files = {files:?}"))?;

        let ret = if files.is_empty() {
            if let Ok(libraries) = optset.get_vals_str("-l=s") {
                for library in libraries {
                    compiler.link_library(&library)?;
                }
            }

            let end_marker = optset.get_val_str("-end=s").unwrap_or("@@End".to_string());
            let main_signature = optset
                .get_val_str("-main=s")
                .unwrap_or("int main(void)".to_string());

            let mut compile_codes = vec![];

            compile_codes.push("#include <stdio.h>".to_string());
            if let Ok(includes) = optset.get_vals_str("-i=s") {
                for include in includes {
                    if include != "stdio.h" {
                        compile_codes.push(format!("#include <{}>", include));
                    }
                }
            }
            if let Ok(pre_process) = optset.get_vals_str("-pp=s") {
                for process in pre_process {
                    compile_codes.push(format!("#{}", process));
                }
            }

            compiler.set_mode(if assemble {
                Mode::Assemble
            } else if expand {
                Mode::Expand
            } else if compile {
                Mode::Compile
            } else {
                Mode::Link
            })?;

            if read_from_stdin {
                Services::log_debug("read code from stdin")?;
                if !codes.is_empty() {
                    Services::log_debug("codes append by -e is ignored")?;
                }
                for code in Services::read_from_stdin(&end_marker)? {
                    compile_codes.push(code);
                }
            } else if !codes.is_empty() {
                compile_codes.push(main_signature);
                compile_codes.push("{".to_string());
                for code in codes {
                    if code.ends_with(";") {
                        compile_codes.push(code);
                    } else {
                        compile_codes.push(format!("{};", code));
                    }
                }
                compile_codes.push("return 0;".to_string());
                compile_codes.push("}".to_string());
            }

            Services::log_debug("try to compile code")?;

            let mut ret = compiler.compile_code(&compile_codes, &output)?;

            ret.clean = !not_clean;
            ret.codes = compile_codes;

            Services::log_debug("compile code successed")?;
            ret
        } else {
            if read_from_stdin {
                Services::log_debug("ignore read from stdin flag")?;
            }
            if !codes.is_empty() {
                Services::log_debug("ignore code append from -e")?;
            }
            let tmpdir = Services::create_tmpdir()?;
            let tmpdir = PathBuf::from(tmpdir);
            let mut objects = vec![];

            compiler.set_mode(Mode::Compile)?;
            for (idx, file) in files.iter().enumerate() {
                let out = tmpdir.join(format!("{}.o", idx));
                let out_path = out.to_string_lossy();
                let ret = compiler.compile_file(file, &out_path)?;

                Services::log_debug(&format!("compile object ret = {ret:?}"))?;
                if ret.cmd_result.ret == 0 {
                    objects.push(out_path.to_string());
                }
            }
            if let Ok(libraries) = optset.get_vals_str("-l=s") {
                for library in libraries {
                    compiler.link_library(&library)?;
                }
            }

            compiler.set_mode(if assemble {
                Mode::Assemble
            } else if expand {
                Mode::Expand
            } else if compile {
                Mode::Compile
            } else {
                Mode::Link
            })?;

            Services::log_debug("try to compile multiple file")?;

            let mut ret = compiler.link_object(&objects, &output)?;

            Services::log_debug("compile multiple file successed")?;
            ret.clean = !not_clean;
            ret
        };

        Services::log_debug(&format!("compile ret = {ret:?}"))?;
        Ok(ret)
    }
}

export!(Language);
