wit_bindgen::generate!({
    path: "wit",
    world: "c",
    with: {
        "snippet:plugin/types@0.1.1": generate,
        "snippet:plugin/language@0.1.1": generate,
        "snippet:plugin/compiler@0.1.1": generate,
    }
});

use std::path::PathBuf;

use exports::snippet::plugin::language::ErrorType;
use exports::snippet::plugin::language::Guest;
use snippet::plugin::compiler::Compiler;
use snippet::plugin::types::Lang;
use snippet::plugin::types::Mode;
use snippet::plugin::types::Optset;
use snippet::plugin::types::Services;
use snippet::plugin::types::Slient;
use snippet::plugin::types::Target;

pub struct Language;

impl Guest for Language {
    fn name() -> Lang {
        Lang::C
    }

    fn fmt() -> String {
        String::from("clang-format=--style=LLVM")
    }

    //     parser.add_opt("-help=b: display help message")?;
    //     parser.add_opt("-S=b: running the compiler in assemble mode")?;
    //     parser.add_opt("-E=b: running the compiler in expand mode")?;
    //     parser.add_opt("-C=b: running the compiler in compile mode")?;
    //     parser.add_opt("-e=s: append code to generator")?;
    //     parser.add_opt("-r=b: ignore value of -e, read code from stdin")?;
    //     parser.add_opt("-end=s: set input code terminator")?;
    //     if cfg!(windows) {
    //         parser
    //             .add_opt("-o: set output name".infer::<String>())?
    //             .set_value("a.exe".to_string());
    //     } else {
    //         parser.add_opt("-o=s: set output name")?;
    //     }
    //     parser.add_opt("-p=b: display code before display stdout")?;
    //     parser.add_opt("-l=s: pass -l to compiler, link given library")?;
    //     parser.add_opt("-L=s: pass -L to compiler, add link library searh path")?;
    //     parser.add_opt("-f=s: pass given flag -<f> to compiler")?;
    //     parser.add_opt("-flag=s: pass given flag --<flag> to compiler")?;
    //     parser.add_opt("-std=s: set language standard version")?;
    //     parser.add_opt("-c=s: select given compiler")?;
    //     parser.add_opt("-m=s: change the main function header")?;
    //     parser.add_opt("-/c=b: don't clean target generated by compiler")?;
    //     parser.add_opt("-arg=s: pass arguments when execute binary")?;
    //     parser.add_opt("-fmt=s: set the code format command")?;
    //     parser.add_opt("-cat=s: set command display the code")?;
    //     parser.add_opt(
    //         "files@1..: ignore -e and -r, compile multiple files"
    //             .infer::<cote::prelude::Pos<String>>(),
    //     )?;
    // There are some default options add to optset
    fn initialize_optset() -> Result<Optset, ErrorType> {
        Optset::default()
    }

    fn fill_optset(optset: Optset) -> Result<Optset, ErrorType> {
        optset.add_opt("-i=s: pass -i to compiler, include given header")?;
        optset.add_opt("-I=s: pass -I to compiler, add include header search path")?;
        optset.add_opt("-D=s: pass -D to compiler, add macro definition")?;
        optset.add_opt("-pp=s: add preprocess command to code")?;
        optset.add_opt("-w=b: pass -Wall -Wextra -Werror to compiler")?;
        Ok(optset)
    }

    fn compile(optset: Optset, compiler: Compiler) -> Result<Target, ErrorType> {
        // set compiler option from optset
        let short_flags = optset.get_vals_str("-f=s");
        let long_flags = optset.get_vals_str("-flag=s");

        if let Ok(flags) = short_flags {
            for flag in flags {
                compiler.add_arg(&flag, false)?;
            }
        }
        if let Ok(flags) = long_flags {
            for flag in flags {
                compiler.add_arg(&flag, true)?;
            }
        }

        let include_paths = optset.get_vals_str("-I=s");
        let library_paths = optset.get_vals_str("-L=s");

        if let Ok(include_paths) = include_paths {
            for include_path in include_paths {
                compiler.add_include_path(&include_path)?;
            }
        }
        if let Ok(library_paths) = library_paths {
            for library_path in library_paths {
                compiler.add_library_path(&library_path)?;
            }
        }

        let macro_definitions = optset.get_vals_str("-D=s");
        let wextra = optset.get_val_bool("-w=b").unwrap_or_default();
        let standard = optset.get_val_str("-std=s");

        if let Ok(definitions) = macro_definitions {
            for definition in definitions {
                compiler.add_macro(&definition, None)?;
            }
        }
        if wextra {
            compiler.enable_warn_error()?;
        }
        if let Ok(standard) = standard {
            compiler.set_standard(&standard)?;
        }

        let assemble = optset.get_val_bool("-S=b").unwrap_or_default();
        let expand = optset.get_val_bool("-E=b").unwrap_or_default();
        let compile = optset.get_val_bool("-C=b").unwrap_or_default();

        #[allow(clippy::nonminimal_bool)]
        if (!assemble && expand && compile)
            || (assemble && !expand && compile)
            || (assemble && expand && !compile)
        {
            Services::log_debug("can't set `assemble`, `expand` or `compile` in same times")?;
            return Err(ErrorType::InvalidMode);
        }

        let not_clean = optset.get_val_bool("-/c=b").unwrap_or_default();
        let from_stdin = optset.get_val_bool("-r=b").unwrap_or_default();
        let codes = optset.get_vals_str("-e=s").unwrap_or_default();
        let files = optset.get_vals_str("files").unwrap_or_default();
        let libraries = optset.get_vals_str("-l=s");
        let stdout = !optset.get_val_bool("-/o=b").unwrap_or_default();
        let stderr = optset.get_val_bool("-/e=b").unwrap_or_default();
        let output = optset.get_val_str("-o=s").unwrap_or(
            if assemble {
                "a.s"
            } else if expand {
                "a.i"
            } else if compile {
                "a.o"
            } else {
                "a.out"
            }
            .to_string(),
        );
        let compiler_mode = if assemble {
            Mode::Assemble
        } else if expand {
            Mode::Expand
        } else if compile {
            Mode::Compile
        } else {
            Mode::Link
        };

        Services::log_debug(&format!("files = {files:?}"))?;

        let ret = if files.is_empty() {
            let end_marker = optset.get_val_str("-end=s").unwrap_or("@@End".to_string());
            let main_signature = optset
                .get_val_str("-main=s")
                .unwrap_or("int main(void)".to_string());

            let includes = optset.get_vals_str("-i=s");
            let pre_processes = optset.get_vals_str("-pp=s");

            let mut compile_codes = vec![];

            compile_codes.push("#include <stdio.h>".to_string());
            if let Ok(includes) = includes {
                for include in includes {
                    if include != "stdio.h" {
                        compile_codes.push(format!("#include <{}>", include));
                    }
                }
            }
            if let Ok(pre_processes) = pre_processes {
                for pre_process in pre_processes {
                    compile_codes.push(format!("#{}", pre_process));
                }
            }
            if let Ok(libraries) = libraries {
                for library in libraries {
                    compiler.add_link_library(&library)?;
                }
            }
            compiler.set_mode(compiler_mode)?;

            if from_stdin {
                Services::log_debug("read code from stdin")?;
                if !codes.is_empty() {
                    Services::log_debug("codes append by -e is ignored")?;
                }
                for code in Services::read_from_stdin(&end_marker)? {
                    compile_codes.push(code);
                }
            } else if !codes.is_empty() {
                compile_codes.push(main_signature);
                compile_codes.push("{".to_string());
                for code in codes {
                    if code.ends_with(";") {
                        compile_codes.push(code);
                    } else {
                        compile_codes.push(format!("{};", code));
                    }
                }
                compile_codes.push("return 0;".to_string());
                compile_codes.push("}".to_string());
            } else {
                return Err(ErrorType::EmptyCode);
            }

            Services::log_debug("try to compile code")?;

            let mut ret =
                compiler.compile_code(&compile_codes, &output, Slient { stderr, stdout })?;

            ret.clean = !not_clean;
            ret.codes = compile_codes;

            Services::log_debug("compile code successed")?;
            ret
        } else {
            if from_stdin {
                Services::log_debug("ignore read from stdin flag")?;
            }
            if !codes.is_empty() {
                Services::log_debug("ignore code append from -e")?;
            }
            let tmpdir = Services::create_tmpdir("snippet-language-c")?;
            let tmpdir = PathBuf::from(tmpdir);
            let mut objects = vec![];

            Services::log_debug(&format!("create a tempdir = {}", tmpdir.display()))?;
            compiler.set_mode(Mode::Compile)?;
            for (idx, file) in files.iter().enumerate() {
                let out = tmpdir.join(format!("{}.o", idx));
                let out_path = out.to_string_lossy();
                let ret = compiler.compile_file(file, &out_path, Slient { stderr, stdout })?;

                Services::log_debug(&format!("compile object ret = {ret:?}"))?;
                if ret.cmd_result.ret == 0 {
                    objects.push(out_path.to_string());
                }
            }
            // link the objects
            if let Ok(libraries) = libraries {
                for library in libraries {
                    compiler.add_link_library(&library)?;
                }
            }
            compiler.set_mode(compiler_mode)?;

            Services::log_debug("try to compile multiple file")?;

            let mut ret = compiler.link_object(&objects, &output, Slient { stderr, stdout })?;

            Services::log_debug("compile multiple file successed")?;
            ret.clean = !not_clean;
            ret
        };

        Services::log_debug(&format!("compile ret = {ret:?}"))?;
        Ok(ret)
    }
}

export!(Language);
