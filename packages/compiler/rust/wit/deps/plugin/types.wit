package snippet:plugin@0.1.0;

interface types {

    enum lang {
        c,

        cxx,

        rust,
    }

    enum mode {
        /// Compile the code to object
        compile,

        /// Expand the macro or do preprocessing
        expand,

        /// Compile the code to assembly
        assemble,

        /// Compile the code and link the object to executable
        link,
    }

    enum error-type {
        /// Not support given mode
        invalid-mode,

        /// Not support given optimization level
        invalid-opt-level,

        /// Not support given language standard
        invalid-standard,

        /// Not found given binary
        invalid-binary,

        /// Invalid language, not supported
        invalid-language,

        /// Invalid option string
        invalid-optstr,

        /// Can not get optset resource from resource table
        invalid-optset-resource,

        /// Can not get services resource from resource table
        invalid-services-resource,

        /// Failed read/write command stdin/stdout
        command-io-failed,

        /// Command need stdin for write
        command-need-stdin,

        /// Failed invoke command
        command-invoke-failed,

        /// Command spawn failed
        command-spawn-failed,

        /// Initialize optset failed
        create-optset-failed,

        /// Can not access value of optset
        access-value-failed,

        empty-code,

        create-dir-failed,
    }

    record binary {
        path: string,
        args: list<string>,
    }

    record source {
        path: string,
    }

    record object {
        path: string,
    }

    variant output {
        binary(binary),
        source(source),
        object(object),
    }

    record target {
        clean: bool,
        output: output,
        codes: list<string>,
        cmd-result: cmd-result,
    }

    record cmd-result {
        out: list<u8>,
        err: list<u8>,
        ret: s32,
    }

    resource optset {
        constructor();

        default: static func() -> result<optset, error-type>;

        /// Add an option to the option set
        add-opt: func(opt: string) -> result<u64, error-type>;

        get-val-bool: func(name: string) -> result<bool, error-type>;

        get-val-str: func(name: string) -> result<string, error-type>;

        get-val-int: func(name: string) -> result<s64, error-type>;

        get-vals-str: func(name: string) -> result<list<string>, error-type>;
    }

    resource services {
        constructor();

        /// Is the compiler in debug mode?
        debug: func() -> result<bool, error-type>;
    
        /// Current language.
        lang: func() -> result<lang, error-type>;
    
        /// Current arguments.
        args: func() -> result<list<string>, error-type>;
    
        /// Current compile mode.
        mode: func() -> result<mode, error-type>;
        
        /// Set the language.
        set-lang: func(language: lang) -> result<_, error-type>;
    
        /// Set debug mode.
        set-debug: func(debug: bool) -> result<_, error-type>;
    
        /// Set the compile mode.
        set-mode: func(mode: mode) -> result<_, error-type>;
    
        /// Add an argument.
        add-arg: func(arg: string) -> result<_, error-type>;
    
        /// Append arguments.
        add-args: func(args: list<string>) -> result<_, error-type>;

        /// Find the executable binary.
        find-bin: static func(bin: string) -> result<string, error-type>;

        /// Invoke the command
        invoke-cmd: static func(bin: string, args: list<string>, stdin: list<string>) -> result<cmd-result, error-type>;

        /// Read from stdin
        read-from-stdin: static func(end: string) -> result<list<string>, error-type>;

        /// Log message to debug channel
        log-debug: static func(log: string) -> result<_, error-type>;

        /// Create a temp dir for objects
        create-tmpdir: static func() -> result<string, error-type>;
    }
}